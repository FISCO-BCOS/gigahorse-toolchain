
/*
  Base, Abstract context sensitivity component
  Is configured using an instantiation of LocalAnalysis
*/
.comp AbstractContextSensitivity <LocalAnalysis> {
  // The Context type is defined by the context implementation components
  // A little hacky to use without defining but its the cleanest approach I found 
  .decl MergeContext(ctx: Context, caller: Block, newContext: Context)

  .decl IsContext(ctx: Context)
  .decl InitialContext(ctx: Context)

  .init local = LocalAnalysis

  IsContext(ctx):-
    InitialContext(ctx).

  // Just making sure everything is captured
  IsContext(ctx):-
    MergeContext(ctx, _, _);
    MergeContext(_, _, ctx).
}

.comp VariableDepthContextSensitivity <LocalAnalysis> : AbstractContextSensitivity <LocalAnalysis> {
  .decl MaxContextDepth(sigHash: symbol, d: number)

  .decl InputMaxContextDepth(d: number)
  .input InputMaxContextDepth(filename="MaxContextDepth.csv")

  MaxContextDepth(sigHash, d) :-
    (local.PublicFunction(_, sigHash);
     sigHash = FALLBACK_FUNCTION_SIGHASH),
    InputMaxContextDepth(d).


  MaxContextDepth(sigHash, 8) :-
    (local.PublicFunction(_, sigHash);
     sigHash = FALLBACK_FUNCTION_SIGHASH),
    !InputMaxContextDepth(_).
}

/**
  Subclasses only need to provide additional MergeContext rules.
*/

.comp PublicComponentContextSensitivity <LocalAnalysis> : VariableDepthContextSensitivity <LocalAnalysis> {
  .type PrivateContext = [block: Block, rest: PrivateContext]
  .type Context = [publicFun:symbol, pri: PrivateContext]

  .decl InitialPrivateContext(ctx: PrivateContext)
  // PrivateContextDepth replaces/enhances IsPrivateContext 
  .decl PrivateContextDepth(ctx: PrivateContext, depth: number)
  .decl DecomposePrivateContext(priCtx: PrivateContext, block: Block, rest: PrivateContext)
  .decl DropLast(ctx: PrivateContext, newCtx: PrivateContext)
  .output DropLast
  .decl TruncateContextIfNeeded(publicFun:symbol, ctx: PrivateContext, newCtx: PrivateContext)
  .decl Context_PublicFunction(ctx:Context, pubFun:symbol)
  .decl DecomposeContext(ctx: Context, publicFun: symbol, private: PrivateContext)

  InitialPrivateContext(nil).

  InitialContext([FALLBACK_FUNCTION_SIGHASH, initialPrivateContext]) :-
    InitialPrivateContext(initialPrivateContext).

  DecomposeContext(ctx, publicFun, private):-
    ReachableContext(ctx, _), ctx = [publicFun, private].

  // Both rules below are needed, DecomposePrivateContext contains a superset of private contexts
  // some of which may not end up being reachable but it needs to because its used in many places
  DecomposePrivateContext(private, block, rest):-
    DecomposeContext(_, _, private),
    private = [block, rest].

  DecomposePrivateContext(private, block, rest):-
    PrivateContextDepth(private, _),
    private = [block, rest].

  DropLast(ctx, nil):-
    DecomposePrivateContext(ctx, _, nil).

  PrivateContextDepth(newCtx, depth - 1),
  DropLast(ctx, newCtx):-
    DecomposePrivateContext(ctx, block, rest),
    PrivateContextDepth(ctx, depth),
    DropLast(rest, newRest),
    newCtx = [ block, newRest ].
    .plan 1:(2,1,3), 2:(3,1,2)

  PrivateContextDepth(init, 0):-
    InitialPrivateContext(init).

  PrivateContextDepth(ctx, depth + 1):-
    DecomposePrivateContext(ctx, _, rest),
    PrivateContextDepth(rest, depth).
    .plan 1:(2,1)

  TruncateContextIfNeeded(pub, ctx, newCtx):-
    PrivateContextDepth(ctx, maxDepth),
    MaxContextDepth(pub, maxDepth),
    DropLast(ctx, newCtx).
    .plan 1:(3,1,2)

  TruncateContextIfNeeded(pub, ctx, ctx):-
    PrivateContextDepth(ctx, depth),
    MaxContextDepth(pub, maxDepth),
    depth < maxDepth.

  Context_PublicFunction(ctx, pubFun):-
    ReachableContext(ctx, _),
    ctx = [pubFun, callCtx],
    callCtx = callCtx.

}

.comp TransactionalContext <LocalAnalysis> : PublicComponentContextSensitivity <LocalAnalysis> {
  // inverse-escape analysis
  .decl Block_Uses_Local(block: Block, var: VariableOrStackIndex)
  .decl StaticBlockJumpTarget(caller: Block, target: Value)
  // We're only interested in private functions
  // No ambiguity for public functions
  .decl PrivateFunctionCallOrReturn(caller: Block)

  Block_Uses_Local(block, var) :-
    local.Statement_Block(stmt, block),
    local.Statement_Uses_Local(stmt, var, _).

  PrivateFunctionCallOrReturn(caller) :-
    StaticBlockJumpTarget(caller, _),
    local.Statement_Block(stmt, caller),
    local.Statement_Defines(stmt, var),
    local.Variable_Value(var, val),
    local.JUMPDEST(as(val, symbol)),
    !Block_Uses_Local(caller, var).

  PrivateFunctionCallOrReturn(caller) :-
    local.Statement_Block(stmt, caller),
    local.JUMP(stmt),
    !local.ImmediateBlockJumpTarget(caller, _).

  StaticBlockJumpTarget(caller, target) :-
    local.ImmediateBlockJumpTarget(caller, targetVar),
    local.Variable_Value(targetVar, target),
    local.JUMPDEST(as(target, symbol)).

  // Trivial control flow case for when there is no function call
  // OR max conext depth is zero
  // Split into two rules to add plan.
  MergeContext(ctx, caller, ctx):-
    ReachableContext(ctx, caller),
    #ifndef NO_PUBLIC_CONTEXT
    !local.PublicFunction(caller, _),
    #endif
    !PrivateFunctionCallOrReturn(caller).

  MergeContext(ctx, caller, ctx):-
    ReachableContext(ctx, caller),
    #ifndef NO_PUBLIC_CONTEXT
    !local.PublicFunction(caller, _),
    #endif
    DecomposeContext(ctx, pub, _),
    MaxContextDepth(pub, 0).
    .plan 1:(2,3,1)

  // Complex control flow case
  MergeContext(ctx, caller, [pub, newPrivateContext]):-
    ReachableContext(ctx, caller),
    PrivateFunctionCallOrReturn(caller),
    DecomposeContext(ctx, pub, pri),
    TruncateContextIfNeeded(pub, pri, cutDownPri),
    #ifndef NO_PUBLIC_CONTEXT
    !local.PublicFunction(caller, _),
    #endif
    newPrivateContext = [caller, cutDownPri].
    .plan 1:(3,1,2,4), 2:(4,3,1,2)

#ifndef NO_PUBLIC_CONTEXT
  MergeContext(ctx, caller, newContext) :-
    ReachableContext(ctx, caller),
    local.PublicFunction(caller, sigHash),
    !MaxContextDepth(sigHash, -1),
    DecomposeContext(ctx, _, pri),
    newContext = [sigHash, pri].
    .plan 1:(3,1,2)
#endif
}

/**
  CallSite context sensitivity with a public function context component
  Does not implement/care for the NO_PUBLIC_CONTEXT flag.
*/
.comp CallSiteContextPlus <LocalAnalysis> : PublicComponentContextSensitivity <LocalAnalysis> {

  MergeContext(ctx, caller, [pub, newPrivateContext]):-
    ReachableContext(ctx, caller),
    DecomposeContext(ctx, pub, pri),
    TruncateContextIfNeeded(pub, pri, cutDownPri),
    !local.PublicFunction(caller, _),
    newPrivateContext = [caller, cutDownPri].
    .plan 1:(2,1,3), 2:(3,2,1)

  MergeContext(ctx, caller, newContext) :-
    ReachableContext(ctx, caller),
    local.PublicFunction(caller, sigHash),
    !MaxContextDepth(sigHash, -1),
    DecomposeContext(ctx, _, pri),
    newContext = [sigHash, pri].
    .plan 1:(3,1,2)

}
