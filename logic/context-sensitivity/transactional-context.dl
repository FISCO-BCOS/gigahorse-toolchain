.type PrivateContext = [block: Block, rest: PrivateContext]

.type Context = [ publicFun:symbol, pri: PrivateContext ]

// find number of jumps to estimate best context depth
.decl MaxContextDepth(d: number)

.decl InputMaxContextDepth(d: number)
.input InputMaxContextDepth(filename="MaxContextDepth.csv")

MaxContextDepth(d) :- InputMaxContextDepth(d).

#ifndef MAX_CONTEXT_DEPTH
  MaxContextDepth(4) :- !InputMaxContextDepth(_).
#else
  MaxContextDepth(MAX_CONTEXT_DEPTH) :- !InputMaxContextDepth(_).
#endif

.decl InitialPrivateContext(ctx : PrivateContext)
InitialPrivateContext(nil).

/*
Keeping this commented for now to see if it makes a difference
.decl IsPrivateContext(ctx:PrivateContext, block:Block, rest:PrivateContext)
IsPrivateContext(nil, "", nil).
*/
.decl DecomposePrivateContext(priCtx: PrivateContext, block: Block, rest: PrivateContext)

.decl DropLast(ctx : PrivateContext, newCtx : PrivateContext)
DropLast(ctx, nil) :-
  DecomposePrivateContext(ctx, _, nil).

DecomposePrivateContext(newCtx, block, newRest),
PrivateContextDepth(newCtx, depth - 1),
DropLast(ctx, newCtx) :-
  DecomposePrivateContext(ctx, block, rest),
  PrivateContextDepth(ctx, depth),
  DropLast(rest, newRest),
  newCtx = [ block, newRest ].
  .plan 1:(2,1,3), 2:(3,1,2)

.decl PrivateContextDepth(ctx : PrivateContext, depth : number)
PrivateContextDepth(init, 0) :-
  InitialPrivateContext(init).

PrivateContextDepth(ctx, depth + 1) :-
  DecomposePrivateContext(ctx, _, rest),
  PrivateContextDepth(rest, depth).
  .plan 1:(2,1)

.decl TruncateContext(ctx : PrivateContext, newCtx : PrivateContext)

TruncateContext(ctx, newCtx) :-
  PrivateContextDepth(ctx, maxDepth),
  MaxContextDepth(maxDepth),
  DropLast(ctx, newCtx).
  .plan 1:(3,1,2)

TruncateContext(ctx, ctx) :-
  PrivateContextDepth(ctx, depth),
  MaxContextDepth(maxDepth),
  depth < maxDepth.

.decl InitialContext(ctx : Context)

InitialContext(["0x0", initialPrivateContext]) :- InitialPrivateContext(initialPrivateContext).


// inverse-escape analysis
.decl Block_Uses_Local(block: Block, var: VariableOrStackIndex)

Block_Uses_Local(block, var) :-
  postTrans.Statement_Block(stmt, block),
  postTrans.Statement_Uses_Local(stmt, var, _).

// We're only interested in private functions
// No ambiguity for public functions
.decl PrivateFunctionCallOrReturn(caller: Block)

PrivateFunctionCallOrReturn(caller) :-
  StaticBlockJumpTarget(caller, _),
  postTrans.Statement_Block(stmt, caller),
  postTrans.Statement_Defines(stmt, var),
  postTrans.Variable_Value(var, val),
  postTrans.JUMPDEST(@cast_to_symbol(val)),
  !Block_Uses_Local(caller, var).

PrivateFunctionCallOrReturn(caller) :-
  postTrans.Statement_Block(stmt, caller),
  postTrans.JUMP(stmt),
  !postTrans.ImmediateBlockJumpTarget(caller, _).


Context_PublicFunction(ctx, pubFun):-
  ReachableContext(ctx, _),
  ctx = [pubFun, callCtx],
  callCtx = callCtx.
  
.decl StaticBlockJumpTarget(caller: Block, target: Value)

StaticBlockJumpTarget(caller, target) :-
  postTrans.ImmediateBlockJumpTarget(caller, targetVar),
  postTrans.Variable_Value(targetVar, target),
  postTrans.JUMPDEST(@cast_to_symbol(target)).

.decl MergeContext(ctx : Context, caller : Block, newContext : Context)

.decl DecomposeContext(ctx:Context, publicFun:symbol, private:PrivateContext)

DecomposeContext(ctx, publicFun, private):-
  ReachableContext(ctx, _), ctx = [publicFun, private].

// Trivial control flow case for when there is no function call
// OR max conext depth is zero
MergeContext(ctx, caller, ctx) :-
  ReachableContext(ctx, caller),
#ifndef NO_PUBLIC_CONTEXT
  !postTrans.PublicFunction(caller, _),
#endif
  (!PrivateFunctionCallOrReturn(caller) ; MaxContextDepth(0)). 

// Complex control flow case

DecomposePrivateContext(newPrivateContext, caller, cutDownPri),
MergeContext(ctx, caller, newContext) :-
  ReachableContext(ctx, caller),
  DecomposeContext(ctx, pub, pri),
  PrivateFunctionCallOrReturn(caller),
#ifndef NO_PUBLIC_CONTEXT
  !postTrans.PublicFunction(caller, _),
#endif
  TruncateContext(pri, cutDownPri),
  newPrivateContext = [caller, cutDownPri],
  newContext = [pub, newPrivateContext].
.plan 1:(2,1,3,4), 2:(4,2,1,3)

#ifndef NO_PUBLIC_CONTEXT
MergeContext(ctx, caller, newContext) :-
  ReachableContext(ctx, caller),
  DecomposeContext(ctx, _, pri),
  postTrans.PublicFunction(caller, sigHash),
  newContext = [sigHash, pri].
#endif

