#include "../clientlib/decompiler_imports.dl"
#include "../clientlib/loops_semantics.dl"
#include "../clientlib/guards.dl"
#include "../clientlib/vulnerability_macros.dl"

// Helper
.decl Conflict_InPublicFunction(stmt:Statement, funcSign:symbol)
Conflict_InPublicFunction(stmt, funcSign) :-
  PublicFunctionSelector(func, funcSign),
  Statement_Function(stmt, func).

.decl Conflict_FunctionWithCallStmt(funSign:symbol)
Conflict_FunctionWithCallStmt(funSign) :-
  CallStmt(stmt),
  Conflict_InPublicFunction(stmt, funSign).

.decl Conflict_StorageAccessInFunction(storageAccessStmt:Statement, pubFunSign:symbol)
Conflict_StorageAccessInFunction(storageAccessStmt, pubFunSign) :-
  (SLOAD(storageAccessStmt, _, _) ; SSTORE(storageAccessStmt, _, _)),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  PublicFunctionSelector(_, pubFunSign).

.decl Conflict_EnvOp(stmt:Statement, to:Variable)
Conflict_EnvOp(stmt, to) :-
  CALLER(stmt, to);ORIGIN(stmt, to);ADDRESS(stmt, to);TIMESTAMP(stmt, to);NUMBER(stmt, to).

.decl Conflict_MSTOREOfConstant(cdl:Statement, constHex:symbol, constNum:number)
Conflict_MSTOREOfConstant(ms, constHex, constNum):-
  MSTORE(ms, _, consVar),
  Variable_Value(consVar, constHex),
  Variable_NumericValue(consVar, constNum).

.decl Conflict_CallDataLoadReadsLength(cdl:Statement, cdl2:Statement, cdlArrayVar:Variable, lenVar:Variable, argLoc:number)
Conflict_CallDataLoadReadsLength(cdl, cdl2, plusFourVar, lenVar, argLoc):-
  CALLDATALOAD(cdl, argIdVar, toVar),
  Variable_NumericValue(argIdVar, argLoc),
  ADDFix(_, toVar, fourVar, plusFourVar),
  Variable_NumericValue(fourVar, 4),
  CALLDATALOAD(cdl2, plusFourVar, lenVar).


// Rrelated to access to dynamic state variables (i.e., mapping, dynamic array)
// 2
.decl Conflict_EnvConflict(storageAccessStmt:Statement, pubFunSign:symbol, op:Opcode, slotNum:StorageIndex)
.output Conflict_EnvConflict
Conflict_EnvConflict(storageAccessStmt, pubFunSign, op, slotNum) :-
  Conflict_EnvOp(stmt, key),
  StorageAccessStmt(storageAccessStmt, slotNum, key),
  Conflict_InPublicFunction(stmt, pubFunSign),
  Statement_Opcode(stmt, op),
  !Conflict_FunctionWithCallStmt(pubFunSign).

// 3
.decl Conflict_FunArgConflict(storageAccessStmt:Statement, pubFunSign:symbol, argIndex:number, slotNum:StorageIndex)
.output Conflict_FunArgConflict
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, argIndex, slotNum) :-
  PublicFunctionArg(pubFun, key, argIndex),
  StorageAccessStmt(storageAccessStmt, slotNum, key), 
  PublicFunctionSelector(pubFun, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).

// calldata
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, (argLoc - 4) / 32, cons) :-
  Conflict_CallDataLoadReadsLength(_, _, _, length, argLoc),
  MLOADFreePtr_To(mloadStmt1, memStart),
  CALLDATACOPY(_, memStart, _, length),
  ADDFix(_, memStart, length, shaStart2),
  MSTORE(mstoreStmt, shaStart2, _),
  MLOADFreePtr_To(mloadStmt2, shaStart),
  SHA3(shaStmt, shaStart, _, storeOffsetVar),
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  MLOADSFreePtrUnchanged(mloadStmt1, mloadStmt2),
  PostDominatesInBlock(shaStmt, mstoreStmt),
  DataFlows(storeOffsetVar, index),
  !MemoryStatement_ActualArg(shaStmt, _, 2),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign),
  Conflict_MSTOREOfConstant(mstoreStmt, mapId, _), 
  cons = STORAGE_CONSTRUCT("MAP", mapId, 0).

// memory
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, (argLoc - 4) / 32, cons) :-
  Conflict_CallDataLoadReadsLength(_, _, lenLocVar, length, argLoc),
  ADDFix(_, lenLocVar, _, cdcStart),
  ADDFix(_, freePtr2, _, memStart),
  CALLDATACOPY(_, memStart, cdcStart, length),
  MLOADFreePtr_To(mloadStmt1, freePtr1),
  MLOADFreePtr_To(_, freePtr2),
  MLOAD(_, freePtr2, loaded),
  ADDFix(_, loaded, freePtr1, shaStart2),
  MSTORE(mstoreStmt, shaStart2, _),
  MLOADFreePtr_To(mloadStmt2, shaStart),
  SUB(_, _, shaStart, result),
  DataFlows(result, len),
  SHA3(shaStmt, shaStart, len, storeOffsetVar),
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  MLOADSFreePtrUnchanged(mloadStmt1, mloadStmt2),
  PostDominatesInBlock(shaStmt, mstoreStmt),
  Conflict_MSTOREOfConstant(mstoreStmt, MapId, _), 
  DataFlows(storeOffsetVar, index),
  !MemoryStatement_ActualArg(shaStmt, _, 2),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign),
  cons = STORAGE_CONSTRUCT("MAP", MapId, 0).

// 4 
.decl Conflict_DynaVarConsConflict(storageAccessStmt:Statement, pubFunSign:symbol, slotNum:StorageIndex, key:number)
.output Conflict_DynaVarConsConflict
Conflict_DynaVarConsConflict(storageAccessStmt, pubFunSign, slotNum, key) :-
  StorageAccessStmt(storageAccessStmt, slotNum, keyVar),
  Variable_Value(keyVar, keyHex),
  key = @hex_to_number(keyHex),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).


// 0 
// Functions with unresolved storage access area(s)
.decl Conflict_MixConflict(pubFunSign:symbol)
.output Conflict_MixConflict
Conflict_MixConflict(pubFunSign) :-
  PublicFunctionSelector(_, pubFunSign),
  all = count: Conflict_StorageAccessInFunction(_, pubFunSign),
  known1 = count: Conflict_BasicVarConsConflict(_, pubFunSign, _),
  known2 = count: Conflict_EnvConflict(_, pubFunSign, _, _),
  known3 = count: Conflict_FunArgConflict(_, pubFunSign, _, _),
  known4 = count: Conflict_DynaVarConsConflict(_, pubFunSign, _, _),
  known = known1 + known2 + known3 + known4,
  all > known.


// Rrelated to access to basic state variables (i.e., string, int, address)
// 4
.decl Conflict_BasicVarConsConflict(storageAccessStmt:Statement, pubFunSign:symbol, slotNum:Value)
.output Conflict_BasicVarConsConflict
Conflict_BasicVarConsConflict(storageAccessStmt, pubFunSign, slotNum) :-
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  Variable_Value(index, slotNum),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).

Conflict_BasicVarConsConflict(storageAccessStmt, pubFunSign, slotNum) :-
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  PHITrans(shaDef, index),
  SHA3_1ARG(_, arg, shaDef),
  Variable_Value(arg, slotNum),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).



// No storage access opcode in the function
// 5
.decl Conflict_NoConflict(pubFunSign:symbol)
.output Conflict_NoConflict
Conflict_NoConflict(pubFunSign) :-
  !Conflict_StorageAccessInFunction(_, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign),
  PublicFunctionSelector(_, pubFunSign).

// 0
.decl Conflict_NoStorageAccessHasContractCalling(pubFunSign:symbol)
.output Conflict_NoStorageAccessHasContractCalling
Conflict_NoStorageAccessHasContractCalling(pubFunSign) :-
  !Conflict_StorageAccessInFunction(_, pubFunSign),
  Conflict_FunctionWithCallStmt(pubFunSign),
  PublicFunctionSelector(_, pubFunSign).