#include "../clientlib/decompiler_imports.dl"
#include "../clientlib/loops_semantics.dl"
#include "../clientlib/guards.dl"
#include "../clientlib/vulnerability_macros.dl"

// Helper
.decl Conflict_InPublicFunction(stmt:Statement, funcSign:symbol)
Conflict_InPublicFunction(stmt, funcSign) :-
  PublicFunctionSelector(func, funcSign),
  Conflict_Statement_Function(stmt, func).

.decl Conflict_Statement_Function(s: Statement, f: Function)
Conflict_Statement_Function(stmt, func) :-
  IsFunction(func),
  Statement_Function(stmt, func).

Conflict_Statement_Function(stmt, caller) :-
  InFunction(block, caller),
  CallGraphEdge(block, callee),
  Statement_Function(stmt, callee).

.decl Conflict_CallStmt(stmt:Statement)
Conflict_CallStmt(stmt) :- Statement_Opcode(stmt, "CALL").
Conflict_CallStmt(stmt) :- Statement_Opcode(stmt, "CALLCODE").
Conflict_CallStmt(stmt) :- Statement_Opcode(stmt, "DELEGATECALL").
Conflict_CallStmt(stmt) :- Statement_Opcode(stmt, "STATICCALL").
Conflict_CallStmt(stmt) :- Statement_Opcode(stmt, "CREATE").
Conflict_CallStmt(stmt) :- Statement_Opcode(stmt, "CREATE2").

.decl Conflict_FunctionWithCallStmt(funSign:symbol)
.output Conflict_FunctionWithCallStmt
Conflict_FunctionWithCallStmt(funSign) :-
  Conflict_CallStmt(stmt),
  Conflict_InPublicFunction(stmt, funSign).

.decl Conflict_StorageAccessInFunction(storageAccessStmt:Statement, pubFunSign:symbol)
Conflict_StorageAccessInFunction(storageAccessStmt, pubFunSign) :-
  (SLOAD(storageAccessStmt, _, _) ; SSTORE(storageAccessStmt, _, _)),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  PublicFunctionSelector(_, pubFunSign).

.decl Conflict_EnvOp(stmt:Statement, to:Variable)
Conflict_EnvOp(stmt, to) :-
  CALLER(stmt, to);ORIGIN(stmt, to);ADDRESS(stmt, to);TIMESTAMP(stmt, to);NUMBER(stmt, to).

.decl Conflict_MSTOREOfConstant(cdl:Statement, constHex:symbol, constNum:number)
Conflict_MSTOREOfConstant(ms, constHex, constNum):-
  MSTORE(ms, _, consVar),
  Variable_Value(consVar, constHex),
  Variable_NumericValue(consVar, constNum).

.decl Conflict_CallDataLoadReadsLength(cdl:Statement, cdl2:Statement, cdlArrayVar:Variable, lenVar:Variable, argLoc:number)
Conflict_CallDataLoadReadsLength(cdl, cdl2, plusFourVar, lenVar, argLoc):-
  CALLDATALOAD(cdl, argIdVar, toVar),
  Variable_NumericValue(argIdVar, argLoc),
  ADDFix(_, toVar, fourVar, plusFourVar),
  Variable_NumericValue(fourVar, 4),
  CALLDATALOAD(cdl2, plusFourVar, lenVar).


// Rrelated to access to dynamic state variables (i.e., mapping, dynamic array)
// 2：存储访问的key是环境参数（op）
.decl Conflict_EnvConflict(storageAccessStmt:Statement, pubFunSign:symbol, op:Opcode, slotNum:StorageIndex)
.output Conflict_EnvConflict
Conflict_EnvConflict(storageAccessStmt, pubFunSign, op, slotNum) :-
  Conflict_EnvOp(stmt, key),
  StorageAccessStmt(storageAccessStmt, slotNum, key),
  Conflict_InPublicFunction(stmt, pubFunSign),
  Statement_Opcode(stmt, op),
  !Conflict_FunctionWithCallStmt(pubFunSign).

// 3：存储访问的key是函数参数
.decl Conflict_FunArgConflict(storageAccessStmt:Statement, pubFunSign:symbol, argIndex:number, slotNum:StorageIndex)
.output Conflict_FunArgConflict

// 函数参数直接作为存储访问的key
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, argIndex, slotNum) :-
  PublicFunctionArg(pubFun, key, argIndex),
  StorageAccessStmt(storageAccessStmt, slotNum, key), 
  PublicFunctionSelector(pubFun, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).

// 函数参数流到编译器构建的函数，再流到存储访问key的位置
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, argIndex, slotNum) :-
  PublicFunctionArg(pubFun, funcArg, argIndex),
  ActualArgs(caller, funcArg, pos),
  FormalArgs(fn, key, pos),
  CallGraphEdge(caller, fn),
  StorageAccessStmt(storageAccessStmt, slotNum, key), 
  PublicFunctionSelector(pubFun, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).

// 一个哈希结果直接用作两次存储访问的key，第二次存储访问的冲突域信息沿用第一次存储访问的冲突域信息，两次存储访问不在同一个基本块
Conflict_FunArgConflict(storageAccessStmt2, pubFunSign, argIndex, slotNum) :-
  Conflict_FunArgConflict(storageAccessStmt1, pubFunSign, argIndex, slotNum),
  SHA3(storageAccessStmt1, _, _, index),
  (SLOAD(storageAccessStmt2, index, _) ; SSTORE(storageAccessStmt2, index, _)),
  Conflict_InPublicFunction(storageAccessStmt2, pubFunSign),
  Statement_Block(storageAccessStmt1, block1),
  !Statement_Block(storageAccessStmt2, block1).

// 一个哈希结果直接用作两次存储访问的key，第二次存储访问的冲突域信息沿用第一次存储访问的冲突域信息，两次存储访问在同一个基本块
Conflict_FunArgConflict(storageAccessStmt3, pubFunSign, argIndex, slotNum) :-
  Conflict_FunArgConflict(storageAccessStmt1, pubFunSign, argIndex, slotNum),
  SHA3(storageAccessStmt1, _, _, index),
  (SLOAD(storageAccessStmt2, _, _) ; SSTORE(storageAccessStmt2, _, _)),
  (SLOAD(storageAccessStmt3, index, _) ; SSTORE(storageAccessStmt3, index, _)),
  HappensAfter(storageAccessStmt2, storageAccessStmt1),
  HappensAfter(storageAccessStmt3, storageAccessStmt2),
  storageAccessStmt2 != storageAccessStmt3,
  Conflict_InPublicFunction(storageAccessStmt3, pubFunSign),
  Statement_Block(storageAccessStmt1, block1),
  Statement_Block(storageAccessStmt2, block1),
  Statement_Block(storageAccessStmt3, block1).

// 一个哈希结果间接用作两次存储访问的key，第二次存储访问的冲突域信息沿用第一次存储访问的冲突域信息，两次存储访问不在同一个基本块
// 间接：哈希结果经过算术运算加工后作为存储访问的key
Conflict_FunArgConflict(storageAccessStmt2, pubFunSign, argIndex, slotNum) :-
  Conflict_FunArgConflict(storageAccessStmt1, pubFunSign, argIndex, slotNum),
  SHA3(storageAccessStmt1, _, _, shaDef),
  ADDFix(_, shaDef, constVar, key),
  Variable_Value(constVar, _),
  (SLOAD(storageAccessStmt2, key, _) ; SSTORE(storageAccessStmt2, key, _)),
  Conflict_InPublicFunction(storageAccessStmt2, pubFunSign),
  Statement_Block(storageAccessStmt1, block1),
  !Statement_Block(storageAccessStmt2, block1).

// 一个哈希结果间接用作两次存储访问的key，第二次存储访问的冲突域信息沿用第一次存储访问的冲突域信息，两次存储访问在同一个基本块
// 间接：哈希结果经过算术运算加工后作为存储访问的key
Conflict_FunArgConflict(storageAccessStmt3, pubFunSign, argIndex, slotNum) :-
  Conflict_FunArgConflict(storageAccessStmt1, pubFunSign, argIndex, slotNum),
  SHA3(storageAccessStmt1, _, _, shaDef),
  ADDFix(_, shaDef, constVar, key),
  Variable_Value(constVar, _),
  (SLOAD(storageAccessStmt2, _, _) ; SSTORE(storageAccessStmt2, _, _)),
  (SLOAD(storageAccessStmt3, key, _) ; SSTORE(storageAccessStmt3, key, _)),
  HappensAfter(storageAccessStmt2, storageAccessStmt1),
  HappensAfter(storageAccessStmt3, storageAccessStmt2),
  storageAccessStmt2 != storageAccessStmt3,
  Conflict_InPublicFunction(storageAccessStmt3, pubFunSign),
  Statement_Block(storageAccessStmt1, block1),
  Statement_Block(storageAccessStmt2, block1),
  Statement_Block(storageAccessStmt3, block1).

// 访问存储的key是memory类型函数参数的部分类容，例如数组元素作为存储访问的key 
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, (argLoc - 4) / 32, slotNum) :-
  Conflict_CallDataLoadReadsLength(_, _, _, lenVar, argLoc),
  MSTORE(_, array, lenVar),
  ArrayIndexAccess(array, indexVar, _),
  MLOAD(_, indexVar, key),
  StorageAccessStmt(storageAccessStmt, slotNum, key), 
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).

// 访问存储的key是calldata类型函数参数的部分类容，例如数组元素作为存储访问的key 
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, (argLoc - 4) / 32, slotNum) :-
  Conflict_CallDataLoadReadsLength(_, _, plusFourVar, _, argLoc),
  ADDFix(_, _, plusFourVar, addResult),
  ADDFix(_, _, addResult, index),
  CALLDATALOAD(_, index, key),
  StorageAccessStmt(storageAccessStmt, slotNum, key), 
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).


// 访问存储的key是calldata类型的string类别的函数参数，字符串直接流到访问存储的key
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, (argLoc - 4) / 32, cons) :-
  Conflict_CallDataLoadReadsLength(_, _, _, length, argLoc),
  MLOADFreePtr_To(mloadStmt1, memStart),
  CALLDATACOPY(_, memStart, _, length),
  ADDFix(_, memStart, length, shaStart2),
  MSTORE(mstoreStmt, shaStart2, _),
  MLOADFreePtr_To(mloadStmt2, shaStart),
  SHA3(shaStmt, shaStart, _, storeOffsetVar),
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  MLOADSFreePtrUnchanged(mloadStmt1, mloadStmt2),
  PostDominatesInBlock(shaStmt, mstoreStmt),
  DataFlows(storeOffsetVar, index),
  !MemoryStatement_ActualArg(shaStmt, _, 2),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign),
  Conflict_MSTOREOfConstant(mstoreStmt, mapId, _), 
  cons = STORAGE_CONSTRUCT("MAP", mapId, 0).

// 访问存储的key是calldata类型的string类别的函数参数，字符串先流到编译器构建的函数再流到访问存储的key
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, (argLoc - 4) / 32, cons) :-
  Conflict_CallDataLoadReadsLength(_, _, _, lenActArg, argLoc),
  ActualArgs(caller, lenActArg, pos),
  FormalArgs(fn, lenForArg, pos),
  CallGraphEdge(caller, fn),
  MLOADFreePtr_To(mloadStmt1, memStart),
  CALLDATACOPY(_, memStart, _, lenForArg),
  ADDFix(_, memStart, lenForArg, shaStart2),
  MSTORE(mstoreStmt, shaStart2, _),
  MLOADFreePtr_To(mloadStmt2, shaStart),
  SHA3(shaStmt, shaStart, _, storeOffsetVar),
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  MLOADSFreePtrUnchanged(mloadStmt1, mloadStmt2),
  PostDominatesInBlock(shaStmt, mstoreStmt),
  DataFlows(storeOffsetVar, index),
  !MemoryStatement_ActualArg(shaStmt, _, 2),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign),
  Conflict_MSTOREOfConstant(mstoreStmt, mapId, _), 
  cons = STORAGE_CONSTRUCT("MAP", mapId, 0).

// 访问存储的key是memory类型的string类别的函数参数，字符串直接流到访问存储的key
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, (argLoc - 4) / 32, cons) :-
  Conflict_CallDataLoadReadsLength(_, _, lenLocVar, length, argLoc),
  ADDFix(_, lenLocVar, _, cdcStart),
  ADDFix(_, freePtr2, _, memStart),
  CALLDATACOPY(_, memStart, cdcStart, length),
  MLOADFreePtr_To(mloadStmt1, freePtr1),
  MLOADFreePtr_To(_, freePtr2),
  MLOAD(_, freePtr2, loaded),
  ADDFix(_, loaded, freePtr1, shaStart2),
  MSTORE(mstoreStmt, shaStart2, _),
  MLOADFreePtr_To(mloadStmt2, shaStart),
  SUB(_, _, shaStart, result),
  DataFlows(result, len),
  SHA3(shaStmt, shaStart, len, storeOffsetVar),
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  MLOADSFreePtrUnchanged(mloadStmt1, mloadStmt2),
  PostDominatesInBlock(shaStmt, mstoreStmt),
  Conflict_MSTOREOfConstant(mstoreStmt, MapId, _), 
  DataFlows(storeOffsetVar, index),
  !MemoryStatement_ActualArg(shaStmt, _, 2),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign),
  cons = STORAGE_CONSTRUCT("MAP", MapId, 0).

// 用函数参数作为key，访问了一个string，这个string是一个struct的成员，struct又是mapping状态变量的value
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, argIndex, slotNum) :-
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  PHITrans(shaDef, index),
  SHA3_1ARG(_, arg, shaDef),
  SHA3_1ARG(_, _, arg),
  SLOAD(stmt, arg, _),
  Conflict_FunArgConflict(stmt, pubFunSign, argIndex, slotNum),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign).

// 用函数参数作为key，访问了string数组的元素，这个string数组是一个struct的成员，struct又是mapping状态变量的value
Conflict_FunArgConflict(storageAccessStmt, pubFunSign, argIndex, slotNum) :-
  SLOAD(stmt, key, _),
  Conflict_FunArgConflict(stmt, pubFunSign, argIndex, slotNum),
  SHA3_1ARG(_, key, shaDef),
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  DataFlows(shaDef, index),
  Conflict_FunArgConflict(stmt, pubFunSign, argIndex, slotNum),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign).

// mapping的key是常数
.decl Conflict_DynaVarConsConflict(storageAccessStmt:Statement, pubFunSign:symbol, slotNum:StorageIndex, key:Value)
.output Conflict_DynaVarConsConflict
Conflict_DynaVarConsConflict(storageAccessStmt, pubFunSign, slotNum, key) :-
  StorageAccessStmt(storageAccessStmt, slotNum, keyVar),
  Variable_Value(keyVar, key),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).


// 0 
// 如果一个函数中，已解析的存储访问操作数量少于函数中所有存储访问操作，则认为该函数不可并行
.decl Conflict_MixConflict(pubFunSign:symbol)
.output Conflict_MixConflict
Conflict_MixConflict(pubFunSign) :-
  PublicFunctionSelector(_, pubFunSign),
  all = count: Conflict_StorageAccessInFunction(_, pubFunSign),
  known1 = count: Conflict_BasicVarConsConflict(_, pubFunSign, _),
  known2 = count: Conflict_EnvConflict(_, pubFunSign, _, _),
  known3 = count: Conflict_FunArgConflict(_, pubFunSign, _, _),
  known4 = count: Conflict_DynaVarConsConflict(_, pubFunSign, _, _),
  known = known1 + known2 + known3 + known4,
  all > known.

// 各种冲突类型的数量
.decl Conflict_Info(pubFunSign:symbol, storageAccessOpcode:number, basicVarConsConflict:number, envConflict:number, funArgConflict:number, dynaVarConsConflict: number)
.output Conflict_Info
Conflict_Info(pubFunSign, storageAccessOpcode, basicVarConsConflict, envConflict, funArgConflict, dynaVarConsConflict) :-
  PublicFunctionSelector(_, pubFunSign),
  storageAccessOpcode = count: Conflict_StorageAccessInFunction(_, pubFunSign),
  basicVarConsConflict = count: Conflict_BasicVarConsConflict(_, pubFunSign, _),
  envConflict = count: Conflict_EnvConflict(_, pubFunSign, _, _),
  funArgConflict = count: Conflict_FunArgConflict(_, pubFunSign, _, _),
  dynaVarConsConflict = count: Conflict_DynaVarConsConflict(_, pubFunSign, _, _).


// 4
// 访问基本状态变量类型
.decl Conflict_BasicVarConsConflict(storageAccessStmt:Statement, pubFunSign:symbol, slotNum:Value)
.output Conflict_BasicVarConsConflict
Conflict_BasicVarConsConflict(storageAccessStmt, pubFunSign, slotNum) :-
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  Variable_Value(index, slotNum),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).

// 存储访问的key是常数的哈希值 
Conflict_BasicVarConsConflict(storageAccessStmt, pubFunSign, slotNum) :-
  (SLOAD(storageAccessStmt, index, _) ; SSTORE(storageAccessStmt, index, _)),
  PHITrans(shaDef, index),
  SHA3_1ARG(_, arg, shaDef),
  Variable_Value(arg, slotNum),
  Conflict_InPublicFunction(storageAccessStmt, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign).


// 5
// 函数中没有存储访问也没有合约调用
.decl Conflict_NoConflict(pubFunSign:symbol)
.output Conflict_NoConflict
Conflict_NoConflict(pubFunSign) :-
  !Conflict_StorageAccessInFunction(_, pubFunSign),
  !Conflict_FunctionWithCallStmt(pubFunSign),
  PublicFunctionSelector(_, pubFunSign).

// 0
// 函数中没有存储访问有合约调用
.decl Conflict_NoStorageAccessHasContractCalling(pubFunSign:symbol)
.output Conflict_NoStorageAccessHasContractCalling
Conflict_NoStorageAccessHasContractCalling(pubFunSign) :-
  !Conflict_StorageAccessInFunction(_, pubFunSign),
  Conflict_FunctionWithCallStmt(pubFunSign),
  PublicFunctionSelector(_, pubFunSign).